source("import2ipm_Growth.R")
source("import2ipm_Survival.R")
source("import2ipm_Recruitment.R")
####
#### Get initial vectors and matrices built --------------
####
inits <- make_inits_ipm(n_spp = n_spp,
iter_matrix_dims = iter_matrix_dims,
max_size = max_size)
####
#### Run simulation -----------------
####
# initial population density vector
nt <- inits$v
# loop through species really quick to set low initial densities
for(i in 1:n_spp) nt[[i]][]=0.001
new.nt <- nt #set initial density vector to be fed into IPM
# set up matrix to record cover
covSave <- matrix(NA,tlimit,n_spp)
covSave[1,] <- sum_cover(inits$v,nt,inits$h,A)
# set up list to store size distributions
sizeSave <- list(NULL)
for(i in 1:n_spp){
sizeSave[[i]] <- matrix(NA,length(inits$v[[i]]),(tlimit))
sizeSave[[i]][,1] <- nt[[i]]/sum(nt[[i]])
}
# initial densities
Nsave <- matrix(NA,tlimit,n_spp)
Nsave[1,] <- sum_N(nt,inits$h)
yrSave <- rep(NA,tlimit)
# Loop through simulation times and iterate population
for (t in 2:(tlimit)){
#draw from observed year effects
allYrs <- c(1:Nyrs)
doYear <- sample(allYrs,1)
yrSave[t] <- doYear
#get recruits per area
cover <- covSave[t-1,]
N <- Nsave[t-1,]
recs_per_area <- get_rpa(Rpars,cover,doYear)
#calculate size-specific crowding
alphaG <- Gpars$alpha
alphaS <- Spars$alpha
if(NoOverlap_Inter==F){#T: heterospecific genets cannot overlap; F: overlap allowed
for(ii in 1:n_spp){
# first do all overlap W's
Xbar=cover*A/N       # multiply by A to get cover back in cm^2
varX=varN(inits$v,nt,inits$h,Xbar,N)
muWG = pi*Xbar*N/(A*alphaG[ii,])
muWS = pi*Xbar*N/(A*alphaS[ii,])
muWG[is.na(muWG)]=0
muWS[is.na(muWS)]=0
inits$WmatG[[ii]]=matrix(muWG,nrow=length(inits$v[[ii]]),ncol=n_spp,byrow=T)
inits$WmatS[[ii]]=matrix(muWS,nrow=length(inits$v[[ii]]),ncol=n_spp,byrow=T)
# now do conspecific no overlap W
inits$Ctot[ii]=inits$h[ii]*sum(inits$expv[[ii]]*nt[[ii]])
inits$Cr[[ii]]=splinefun(inits$b.r[[ii]],inits$h[ii]*c(0,cumsum(inits$expv[[ii]]*nt[[ii]])),method="natural")
inits$WmatG[[ii]][,ii]=WrijG(inits$v.r[[ii]],ii,ii,inits$r.U,inits$Cr,inits$Ctot)/A
inits$WmatS[[ii]][,ii]=WrijS(inits$v.r[[ii]],ii,ii,inits$r.U,inits$Cr,inits$Ctot)/A
}
}else{
for(ii in 1:n_spp){
inits$Ctot[ii]=inits$h[ii]*sum(inits$expv[[ii]]*nt[[ii]])
inits$Cr[[ii]]=splinefun(inits$b.r[[ii]],inits$h[ii]*c(0,cumsum(inits$expv[[ii]]*nt[[ii]])),method="natural")
}
for(jj in 1:n_spp){
WfunG=splinefun(inits$size.range,WrijG(inits$size.range,jj,jj,inits$r.U,inits$Cr,inits$Ctot))
WfunS=splinefun(inits$size.range,WrijS(inits$size.range,jj,jj,inits$r.U,inits$Cr,inits$Ctot))
for(ii in 1:n_spp) {
inits$WmatG[[ii]][,jj]=WfunG(inits$v.r[[ii]])/A
inits$WmatS[[ii]][,jj]=WfunS(inits$v.r[[ii]])/A
}
}
} # end NoOverlap if
for(doSpp in 1:n_spp){
if(cover[doSpp]>0){
# make kernels and project
K_matrix=make_K_matrix(inits$v[[doSpp]],inits$WmatG[[doSpp]],inits$WmatS[[doSpp]],
Rpars,recs_per_area,Gpars,Spars,doYear,doSpp,inits$h)
new.nt[[doSpp]]=K_matrix%*%nt[[doSpp]]
sizeSave[[doSpp]][,i]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])
}
} # next species
nt=new.nt
covSave[t,]=sum_cover(inits$v,nt,inits$h,A)  # store the cover as cm^2/cm^2
Nsave[t,]=sum_N(nt,inits$h)
print(t)
flush.console()
if(sum(is.na(nt))>0) browser()
} # next time step
## Figures ==============================================================
par(mfrow=c(2,2),tcl=-0.2,mgp=c(2,0.5,0))
myCol<-c("forestgreen","red","blue","pink")
#cover
boxplot(as.data.frame(100*covSave[(burn.in+1):tlimit,]),ylab="Cover (%)",names=sppList,col=myCol)
abline(h=0)
#density
boxplot(as.data.frame(Nsave[(burn.in+1):tlimit,]),ylab="Density",names=sppList,col=myCol)
abline(h=0)
# average size distribution
plot(1,1,type="n",xlim=c(log(0.15),log(max(maxSize))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
for(i in 1:Nspp){
lines(v[[i]],rowMeans(sizeSave[[i]][,(burn.in+1):tlimit]),col=myCol[i])
}
# example time series
matplot((burn.in+1):tlimit,100*covSave[(burn.in+1):tlimit,],type="l",col=myCol,xlab="Time",ylab="Cover (%)")
## Figures ==============================================================
par(mfrow=c(2,2),tcl=-0.2,mgp=c(2,0.5,0))
myCol<-c("forestgreen","red","blue","pink")
#cover
boxplot(as.data.frame(100*covSave[(burn_in+1):tlimit,]),ylab="Cover (%)",names=sppList,col=myCol)
abline(h=0)
par(mfrow=c(2,2),tcl=-0.2,mgp=c(2,0.5,0))
myCol<-c("forestgreen","red","blue","pink")
#cover
boxplot(as.data.frame(100*covSave[(burn_in+1):tlimit,]),ylab="Cover (%)",names=spp_list,col=myCol)
abline(h=0)
#density
#density
boxplot(as.data.frame(Nsave[(burn_in+1):tlimit,]),ylab="Density",names=spp_list,col=myCol)
abline(h=0)
# average size distribution
plot(1,1,type="n",xlim=c(log(0.15),log(max(maxSize))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
for(i in 1:Nspp){
lines(v[[i]],rowMeans(sizeSave[[i]][,(burn_in+1):tlimit]),col=myCol[i])
}
# example time series
matplot((burn_in+1):tlimit,100*covSave[(burn_in+1):tlimit,],type="l",col=myCol,xlab="Time",ylab="Cover (%)")
# average size distribution
plot(1,1,type="n",xlim=c(log(0.15),log(max(maxSize))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
for(i in 1:n_spp){
lines(v[[i]],rowMeans(sizeSave[[i]][,(burn_in+1):tlimit]),col=myCol[i])
}
plot(1,1,type="n",xlim=c(log(0.15),log(max(maxSize))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
names(inits)
plot(1,1,type="n",xlim=c(log(0.15),log(max(max_size))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
for(i in 1:n_spp){
lines(v[[i]],rowMeans(sizeSave[[i]][,(burn_in+1):tlimit]),col=myCol[i])
}
for(i in 1:n_spp){
lines(inits$v[[i]],rowMeans(sizeSave[[i]][,(burn_in+1):tlimit]),col=myCol[i])
}
# average size distribution
plot(1,1,type="n",xlim=c(log(0.15),log(max(max_size))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
for(i in 1:n_spp){
lines(inits$v[[i]],rowMeans(sizeSave[[i]][,(burn_in+1):tlimit]),col=myCol[i])
}
sizeSave
###############################################################
#### Script to run a multi-species IPM using Idaho data and
#### the 'IPMdoit' package.
####
#### Andrew Tredennick
#### 1-29-2015
# Clear the workspace
rm(list=ls(all=TRUE))
####
#### Load required packages -----------------------
####
library(IPMdoit)
library(boot); library(mvtnorm)
library(msm); library(statmod)
####
#### Set up global parameters ---------------------
####
A <- 10000 #Area of 100cm x 100cm quadrat
tlimit <- 1000  ## number of years to simulate
burn_in <- 500    # years to cut before calculations
spp_list <- c("ARTR","HECO","POSE","PSSP")
iter_matrix_dims <- c(75,75,50,50)     #Set matrix dimension for each species
max_size <- c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs <- 22
doGroup <- NA  # NA for spatial avg., values 1-6 for a specific group
n_spp <- length(spp_list)
NoOverlap_Inter=F
####
#### Source import scripts to bring in vital rate functions and parameters -------------
####
source("import2ipm_Growth.R")
source("import2ipm_Survival.R")
source("import2ipm_Recruitment.R")
####
#### Get initial vectors and matrices built --------------
####
inits <- make_inits_ipm(n_spp = n_spp,
iter_matrix_dims = iter_matrix_dims,
max_size = max_size)
####
#### Run simulation -----------------
####
# initial population density vector
nt <- inits$v
# loop through species really quick to set low initial densities
for(i in 1:n_spp) nt[[i]][]=0.001
new.nt <- nt #set initial density vector to be fed into IPM
# set up matrix to record cover
covSave <- matrix(NA,tlimit,n_spp)
covSave[1,] <- sum_cover(inits$v,nt,inits$h,A)
# set up list to store size distributions
sizeSave <- list(NULL)
for(i in 1:n_spp){
sizeSave[[i]] <- matrix(NA,length(inits$v[[i]]),(tlimit))
sizeSave[[i]][,1] <- nt[[i]]/sum(nt[[i]])
}
# initial densities
Nsave <- matrix(NA,tlimit,n_spp)
Nsave[1,] <- sum_N(nt,inits$h)
yrSave <- rep(NA,tlimit)
# Loop through simulation times and iterate population
for (t in 2:(tlimit)){
#draw from observed year effects
allYrs <- c(1:Nyrs)
doYear <- sample(allYrs,1)
yrSave[t] <- doYear
#get recruits per area
cover <- covSave[t-1,]
N <- Nsave[t-1,]
recs_per_area <- get_rpa(Rpars,cover,doYear)
#calculate size-specific crowding
alphaG <- Gpars$alpha
alphaS <- Spars$alpha
if(NoOverlap_Inter==F){#T: heterospecific genets cannot overlap; F: overlap allowed
for(ii in 1:n_spp){
# first do all overlap W's
Xbar=cover*A/N       # multiply by A to get cover back in cm^2
varX=varN(inits$v,nt,inits$h,Xbar,N)
muWG = pi*Xbar*N/(A*alphaG[ii,])
muWS = pi*Xbar*N/(A*alphaS[ii,])
muWG[is.na(muWG)]=0
muWS[is.na(muWS)]=0
inits$WmatG[[ii]]=matrix(muWG,nrow=length(inits$v[[ii]]),ncol=n_spp,byrow=T)
inits$WmatS[[ii]]=matrix(muWS,nrow=length(inits$v[[ii]]),ncol=n_spp,byrow=T)
# now do conspecific no overlap W
inits$Ctot[ii]=inits$h[ii]*sum(inits$expv[[ii]]*nt[[ii]])
inits$Cr[[ii]]=splinefun(inits$b.r[[ii]],inits$h[ii]*c(0,cumsum(inits$expv[[ii]]*nt[[ii]])),method="natural")
inits$WmatG[[ii]][,ii]=WrijG(inits$v.r[[ii]],ii,ii,inits$r.U,inits$Cr,inits$Ctot)/A
inits$WmatS[[ii]][,ii]=WrijS(inits$v.r[[ii]],ii,ii,inits$r.U,inits$Cr,inits$Ctot)/A
}
}else{
for(ii in 1:n_spp){
inits$Ctot[ii]=inits$h[ii]*sum(inits$expv[[ii]]*nt[[ii]])
inits$Cr[[ii]]=splinefun(inits$b.r[[ii]],inits$h[ii]*c(0,cumsum(inits$expv[[ii]]*nt[[ii]])),method="natural")
}
for(jj in 1:n_spp){
WfunG=splinefun(inits$size.range,WrijG(inits$size.range,jj,jj,inits$r.U,inits$Cr,inits$Ctot))
WfunS=splinefun(inits$size.range,WrijS(inits$size.range,jj,jj,inits$r.U,inits$Cr,inits$Ctot))
for(ii in 1:n_spp) {
inits$WmatG[[ii]][,jj]=WfunG(inits$v.r[[ii]])/A
inits$WmatS[[ii]][,jj]=WfunS(inits$v.r[[ii]])/A
}
}
} # end NoOverlap if
for(doSpp in 1:n_spp){
if(cover[doSpp]>0){
# make kernels and project
K_matrix=make_K_matrix(inits$v[[doSpp]],inits$WmatG[[doSpp]],inits$WmatS[[doSpp]],
Rpars,recs_per_area,Gpars,Spars,doYear,doSpp,inits$h)
new.nt[[doSpp]]=K_matrix%*%nt[[doSpp]]
sizeSave[[doSpp]][,t]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])
}
} # next species
nt=new.nt
covSave[t,]=sum_cover(inits$v,nt,inits$h,A)  # store the cover as cm^2/cm^2
Nsave[t,]=sum_N(nt,inits$h)
print(t)
flush.console()
if(sum(is.na(nt))>0) browser()
} # next time step
## Figures ==============================================================
par(mfrow=c(2,2),tcl=-0.2,mgp=c(2,0.5,0))
myCol<-c("forestgreen","red","blue","pink")
#cover
boxplot(as.data.frame(100*covSave[(burn_in+1):tlimit,]),ylab="Cover (%)",names=spp_list,col=myCol)
abline(h=0)
#density
boxplot(as.data.frame(Nsave[(burn_in+1):tlimit,]),ylab="Density",names=spp_list,col=myCol)
abline(h=0)
# average size distribution
plot(1,1,type="n",xlim=c(log(0.15),log(max(max_size))),ylim=c(0,0.5),xlab="Size",ylab="Frequency")
for(i in 1:n_spp){
lines(inits$v[[i]],rowMeans(sizeSave[[i]][,(burn_in+1):tlimit]),col=myCol[i])
}
# example time series
matplot((burn_in+1):tlimit,100*covSave[(burn_in+1):tlimit,],type="l",col=myCol,xlab="Time",ylab="Cover (%)")
cover_d <- as.data.frame(100*covSave[(burn_in+1):tlimit,])
head(cover_d)
seq((burn_in+1):tlimit))
seq((burn_in+1),tlimit)
cover <- as.data.frame(100*covSave[(burn_in+1):tlimit,])
colnames(cover) <- spp_list
cover$year <- seq((burn_in),tlimit)
cover <- as.data.frame(100*covSave[(burn_in+1):tlimit,])
colnames(cover) <- spp_list
cover$year <- seq((burn_in+1),tlimit)
cover_df <- melt(cover_df)
library(plyr); library(reshape2)
library(ggplot2)
cover_df <- melt(cover_df)
cover <- as.data.frame(100*covSave[(burn_in+1):tlimit,])
colnames(cover) <- spp_list
cover$year <- seq((burn_in+1),tlimit)
cover_df <- melt(cover)
head(cover_df)
cover_df <- melt(cover, id.vars = "year")
head(cover_df)
ggplot(cover_df)+
geom_boxplot(aes(x=Species, y=Cover, fill=Species))
colnames(cover_df) <- c("Sim_Year", "Species", "Cover")
ggplot(cover_df)+
geom_boxplot(aes(x=Species, y=Cover, fill=Species))
ggplot(cover_df)+
geom_line(aes(x=Sim_Year, y=Cover, color=Species, group=Species))
library(gridExtra)
g_cover_box <- ggplot(cover_df)+
geom_boxplot(aes(x=Species, y=Cover, fill=Species))+
guides(fill=FALSE)
g_cover_ts <- ggplot(cover_df)+
geom_line(aes(x=Sim_Year, y=Cover, color=Species, group=Species))
grid.arrange(g_cover_box, g_cover_ts, nrow=1, ncol=2)
print(paste("Done with year", t, "of", tlimit))
source('~/Repos/IPMdoit/inst/examples/run_idaho_example.R', echo=TRUE)
setwd("~/Dropbox/sagebrush_class_2013/Wyoming/coverIBM/Bayes")
#clear everything, just to be safe
rm(list=ls(all=TRUE))
####
#### Load libraries
####
library(nimble)
library(ggplot2)
library(tidyr)
####
#### Bring in data
####
studyArea="1"
ifelse(studyArea=="1",
climD<-read.csv("../../studyarea1/climate/DAYMET/FormattedClimate_WY_SA1.csv"),
climD<-read.csv("../../studyarea2/climate/DAYMET/FormattedClimate_WY_SA2.csv"))
ifelse(studyArea=="1",
rawD<-read.csv("../../cover_structure/WY_SAGECoverData_V2check.csv"),
rawD<-read.csv("../../cover_structure/WY_SAGECoverData_SA2.csv"))
# merge in climate data
fullD <- merge(rawD,climD,by.x="Year", by.y="year",all.x=T)
# get knot data
load("Knot_cell_distances.Rdata")
####
#### Take subset of data for test fitting
####
# rown <- 169
# rows <- 1
# ntest <- rown*rows
#
# subD <- subset(fullD, ID<(ntest+1))
# growD <- subset(subD, is.na(CoverLag)==FALSE)
growD <- subset(fullD, Year>1984)
growD <- subset(growD, Year<1986)
# growD <- subset(fullD, Year>=1985 & Year<=1987)
# coords.mod <- as.matrix(growD[,c("Lon", "Lat")])
# D <- as.matrix(dist(coords.mod))
####
#### Quick glm for initial values ----------------------
####
mod <- glm(Cover ~ CoverLag, family="poisson", data=growD)
summary(mod)
init_alpha <- as.numeric(coef(mod)[1])
init_beta <- as.numeric(coef(mod)[2])
####
#### Set up data structure for NIMBLE ----------------------
####
index <- which(is.na(growD$Cover)==FALSE) #vector of rows of non-missing data
N.obs <- growD$Cover[index]
lagObs <- growD$CoverLag[index]
cell  <- growD$ID[index]
K <- K.data$K
nKnots <- ncol(K)
dim(K)
aaa <- rnorm(81,1,0)
aaa
aaa <- rnorm(81,0,1)
aaa
ttt <- K%*%aaa
dim(ttt)
setwd("~/Dropbox/sagebrush_class_2013/Wyoming/coverIBM/Bayes")
#clear everything, just to be safe
rm(list=ls(all=TRUE))
####
#### Load libraries
####
library(nimble)
library(ggplot2)
library(tidyr)
####
#### Bring in data
####
studyArea="1"
ifelse(studyArea=="1",
climD<-read.csv("../../studyarea1/climate/DAYMET/FormattedClimate_WY_SA1.csv"),
climD<-read.csv("../../studyarea2/climate/DAYMET/FormattedClimate_WY_SA2.csv"))
ifelse(studyArea=="1",
rawD<-read.csv("../../cover_structure/WY_SAGECoverData_V2check.csv"),
rawD<-read.csv("../../cover_structure/WY_SAGECoverData_SA2.csv"))
# merge in climate data
fullD <- merge(rawD,climD,by.x="Year", by.y="year",all.x=T)
# get knot data
load("Knot_cell_distances.Rdata")
####
#### Take subset of data for test fitting
####
# rown <- 169
# rows <- 1
# ntest <- rown*rows
#
# subD <- subset(fullD, ID<(ntest+1))
# growD <- subset(subD, is.na(CoverLag)==FALSE)
growD <- subset(fullD, Year>1984)
growD <- subset(growD, Year<1986)
# growD <- subset(fullD, Year>=1985 & Year<=1987)
# coords.mod <- as.matrix(growD[,c("Lon", "Lat")])
# D <- as.matrix(dist(coords.mod))
####
#### Quick glm for initial values ----------------------
####
mod <- glm(Cover ~ CoverLag, family="poisson", data=growD)
summary(mod)
init_alpha <- as.numeric(coef(mod)[1])
init_beta <- as.numeric(coef(mod)[2])
####
#### Set up data structure for NIMBLE ----------------------
####
index <- which(is.na(growD$Cover)==FALSE) #vector of rows of non-missing data
N.obs <- growD$Cover[index]
lagObs <- growD$CoverLag[index]
cell  <- growD$ID[index]
K <- K.data$K
nKnots <- ncol(K)
constants <- list(nObs=length(N.obs), nKnots=nKnots)
data <- list(C = N.obs,
N = lagObs,
K = K,
cell = cell)
inits <- list(intMu=init_alpha, betaMu=init_beta, alpha=rep(0,nKnots))
setwd("~/Dropbox/sagebrush_class_2013/Wyoming/coverIBM/Bayes")
#clear everything, just to be safe
rm(list=ls(all=TRUE))
####
#### Load libraries
####
library(nimble)
library(ggplot2)
library(tidyr)
####
#### Bring in data
####
studyArea="1"
ifelse(studyArea=="1",
climD<-read.csv("../../studyarea1/climate/DAYMET/FormattedClimate_WY_SA1.csv"),
climD<-read.csv("../../studyarea2/climate/DAYMET/FormattedClimate_WY_SA2.csv"))
ifelse(studyArea=="1",
rawD<-read.csv("../../cover_structure/WY_SAGECoverData_V2check.csv"),
rawD<-read.csv("../../cover_structure/WY_SAGECoverData_SA2.csv"))
# merge in climate data
fullD <- merge(rawD,climD,by.x="Year", by.y="year",all.x=T)
# get knot data
load("Knot_cell_distances.Rdata")
####
#### Take subset of data for test fitting
####
# rown <- 169
# rows <- 1
# ntest <- rown*rows
#
# subD <- subset(fullD, ID<(ntest+1))
# growD <- subset(subD, is.na(CoverLag)==FALSE)
growD <- subset(fullD, Year>1984)
growD <- subset(growD, Year<1986)
# growD <- subset(fullD, Year>=1985 & Year<=1987)
# coords.mod <- as.matrix(growD[,c("Lon", "Lat")])
# D <- as.matrix(dist(coords.mod))
####
#### Quick glm for initial values ----------------------
####
mod <- glm(Cover ~ CoverLag, family="poisson", data=growD)
summary(mod)
init_alpha <- as.numeric(coef(mod)[1])
init_beta <- as.numeric(coef(mod)[2])
####
#### Set up data structure for NIMBLE ----------------------
####
index <- which(is.na(growD$Cover)==FALSE) #vector of rows of non-missing data
N.obs <- growD$Cover[index]
lagObs <- growD$CoverLag[index]
cell  <- growD$ID[index]
K <- K.data$K
nKnots <- ncol(K)
constants <- list(nObs=length(N.obs), nKnots=nKnots)
data <- list(C = N.obs,
N = lagObs,
K = K,
cell = cell)
inits <- list(intMu=init_alpha, betaMu=init_beta, alpha=rep(0,nKnots))
inits
data
dim(data)
dim(data$K)
Nobs
N.obs
length(N.obs)
K <- K.data$K[index]
dim(K)
K <- K.data$K[index,]
dim(K)
nKnots <- ncol(K)
nKnots
