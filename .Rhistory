library(IPMdoit)
help(make_inits_ipm)
library(devtools)
library(IPMdoit)
devtools::document()
?make_inits_ipm
setwd("~/Repos/Diversity_Stability/PopModels/idahoIPM")
# Multispecies, spatially implicit IPM
# This version makes it possible to assume "no overlap"
# for intraspecific competition only or intra- and interspecific competition
# ATT 8/26/14
outfile1="ipm_cover.csv"
outfile2="stable_size.csv"
# obsClimateFile="Climate.csv"
perturbPpt=F
perturbTemp=F
# climYrSave=read.csv("climYears.csv")  # use same sequence of years used for observed run
# randYrSave=read.csv("randYears.csv")
A=10000 #Area of 100cm x 100cm quadrat
tlimit=2500 ## number of years to simulate
burn.in=500    # years to cut before calculations
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=22
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
constant=F
NoOverlap.Inter=F
compScale=F
#============================================================
# (I) LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
# get climate data
# obsD=read.csv(obsClimateFile)
# climD=obsD[,2:NCOL(obsD)]  #drop year column
# climD$ppt1.TmeanSpr1=climD$ppt1*climD$TmeanSpr1
# climD$ppt2.TmeanSpr2=climD$ppt2*climD$TmeanSpr2
# climDmean=colMeans(climD); climDsd=apply(climD,MARGIN=2,FUN=sd)
# set up survival parameters and function
source("./survival/import2ipm_noOverlap.r")
# set up growth parameters and function
source("./growth/cache/import2ipm_noOverlap.r")
# set up recruitment parameters and function
source("./recruitment/import2ipm.r")
# model spatial group variation (or not)
if(!is.na(doGroup)){
Spars$intcpt=Spars$intcpt+Spars$intcpt.gr[doGroup,]
Gpars$intcpt=Gpars$intcpt+Gpars$intcpt.gr[doGroup,]
Rpars$intcpt.yr=Rpars$intcpt.yr+matrix(Rpars$intcpt.gr[doGroup,],Nyrs,Nspp,byrow=T)
}
# PERTURB PARAMETERS -------------------------------------
# perturb precip (increase 1 %)
if(perturbPpt==T){
pptVars=grep("ppt",names(climD))
tmp1=0.01*colMeans(climD)
tmp1=matrix(tmp1,NROW(climD),length(tmp1),byrow=T)
climD[,pptVars]=climD[,pptVars]+tmp1[,pptVars]
#downscaled climate projections
#climD$pptLag=climD$pptLag*1.005
#climD$ppt1=climD$ppt1*1.027
#climD$ppt2=climD$ppt2*1.027
}
# perturb temperature (increase all temps by 1 % of spring temps)
if(perturbTemp==T){
tempVars=grep("Tmean",names(climD))
tmp1=0.01*mean(climD$TmeanSpr1)
#tmp1=0.254*mean(climD$TmeanSpr1)   # downscaled projections
tmp1=matrix(tmp1,NROW(climD),NCOL(climD),byrow=T)
climD[,tempVars]=climD[,tempVars]+tmp1[,tempVars]
}
# recalculate climate interactions
# climD$ppt1.TmeanSpr1=climD$ppt1*climD$TmeanSpr1
# climD$ppt2.TmeanSpr2=climD$ppt2*climD$TmeanSpr2
if(constant==T){
# turn off climate variation
climD=matrix(climDmean,Nyrs,NCOL(climD),byrow=T)
#turn off random year effects
#Rpars$intcpt.yr=matrix(Rpars$intcpt.mu,Nyrs,Nspp,byrow=T)
#Gpars$intcpt.yr[]=0;Gpars$slope.yr[]=0
#Spars$intcpt.yr[]=0;Spars$slope.yr[]=0
}
if(compScale==T){
tmp <- matrix(rep(-0.1, length(Gpars$nb)), nrow = 4)
for(i in 1:Nspp){
tmp[i,i] <- Gpars$nb[i,i]
}
Gpars$nb <- tmp
}
#============================================================================================#
# (II) Simulation length, Matrix size and initial vectors
#============================================================================================#
v=v.r=b.r=expv=Cr=WmatG=WmatS=list(4)
h=r.L=r.U=Ctot=numeric(4)
for(i in 1:Nspp){
# minimum (0.9*minimum size from data) and maximum sizes (1.1*maximum size from data)
L=log(0.2)
U=log(maxSize[i])*1.1
# boundary points b and mesh points y. Note: b chops up the size interval (L-U) into bigM-equal-sized portions.
b = L+c(0:bigM[i])*(U-L)/bigM[i]
# v calculates the middle of each n-equal-sized portion.
v[[i]] = 0.5*(b[1:bigM[i]]+b[2:(bigM[i]+1)])
# step size for midpoint rule. (see equations 4 and 5 in Ellner and Rees (2006) Am Nat.)
h[i] = v[[i]][2]-v[[i]][1]
# variables for Wr approximation
b.r[[i]]=sqrt(exp(b)/pi)
v.r[[i]]=sqrt(exp(v[[i]])/pi)
expv[[i]]=exp(v[[i]])
r.L[i] = sqrt(exp(L)/pi)
r.U[i] = sqrt(exp(U)/pi)
WmatG[[i]]=matrix(NA,length(v.r[[i]]),Nspp)  # storage of size-specific W values for each focal species
WmatS[[i]]=matrix(NA,length(v.r[[i]]),Nspp)
} # next species
tmp=range(v.r)
size.range=seq(tmp[1],tmp[2],length=50) # range across all possible sizes
#============================================================================================#
# (III) Utility functions
#============================================================================================#
# load the necessary libraries
library(boot)
library(mvtnorm)
library(msm)
library(statmod)
## combined kernel
make.K.values=function(v,u,muWG,muWS, #state variables
Rpars,rpa,Gpars,Spars,doYear,doSpp){  #growth arguments
f(v,u,Rpars,rpa,doSpp)+S(u,muWS,Spars,doYear,doSpp)*G(v,u,muWG,Gpars,doYear,doSpp)
}
# Function to make iteration matrix based only on mean crowding
make.K.matrix=function(v,muWG,muWS,Rpars,rpa,Gpars,Spars,doYear,doSpp) {
muWG=expandW(v,v,muWG)
muWS=expandW(v,v,muWS)
K.matrix=outer(v,v,make.K.values,muWG,muWS,Rpars,rpa,Gpars,Spars,doYear,doSpp)
return(h[doSpp]*K.matrix)
}
# Function to format the W matrix for the outer product
expandW=function(v,u,W){
if(dim(W)[1]!=length(u)) stop("Check size of W")
Nspp=dim(W)[2]
W=as.vector(W)
W=matrix(W,length(W),ncol=length(v))
W=as.vector(t(W))
W=matrix(W,nrow=length(u)*length(v),ncol=Nspp)
return(W)
}
# Function to calculate size-dependent crowding, assuming no overlap
wrijG=function(r,i,j){
return(2*pi*integrate(function(z) z*exp(-alphaG[i,j]*(z^2))*Cr[[j]](z-r),r,r+r.U[j])$value+
pi*Ctot[j]*exp(-alphaG[i,j]*((r+r.U[j])^2))/alphaG[i,j]);
}
WrijG=Vectorize(wrijG,vectorize.args="r")
wrijS=function(r,i,j){
return(2*pi*integrate(function(z) z*exp(-alphaS[i,j]*(z^2))*Cr[[j]](z-r),r,r+r.U[j])$value+
pi*Ctot[j]*exp(-alphaS[i,j]*((r+r.U[j])^2))/alphaS[i,j]);
}
WrijS=Vectorize(wrijS,vectorize.args="r")
WrijS
