{
    "contents" : "###############################################################\n#### Script to run a multi-species IPM using Idaho data and\n#### the 'IPMdoit' package.\n####\n#### Andrew Tredennick\n#### 1-29-2015\n\n# Clear the workspace\nrm(list=ls(all=TRUE))\n\n####\n#### Load required packages -----------------------\n####\nlibrary(IPMdoit); library(ggplot2)\nlibrary(boot); library(mvtnorm)\nlibrary(msm); library(statmod)\nlibrary(plyr); library(reshape2)\nlibrary(gridExtra)\n\n\n####\n#### Set up global parameters ---------------------\n####\nA <- 10000 #Area of 100cm x 100cm quadrat\ntlimit <- 1000  ## number of years to simulate\nburn_in <- 500    # years to cut before calculations\nspp_list <- c(\"ARTR\",\"HECO\",\"POSE\",\"PSSP\")\niter_matrix_dims <- c(75,75,50,50)     #Set matrix dimension for each species\nmax_size <- c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2\nNyrs <- 22\ndoGroup <- NA  # NA for spatial avg., values 1-6 for a specific group\nn_spp <- length(spp_list)\nNoOverlap_Inter=F\n\n####\n#### Source import scripts to bring in vital rate functions and parameters ------------- \n####\nsource(\"import2ipm_Growth.R\")\nsource(\"import2ipm_Survival.R\")\nsource(\"import2ipm_Recruitment.R\")\n\n####\n#### Get initial vectors and matrices built --------------\n####\ninits <- make_inits_ipm(n_spp = n_spp, \n                        iter_matrix_dims = iter_matrix_dims, \n                        max_size = max_size)\n\n\n####\n#### Run simulation -----------------\n####\n# initial population density vector\nnt <- inits$v\n\n# loop through species really quick to set low initial densities\nfor(i in 1:n_spp) nt[[i]][]=0.001\nnew.nt <- nt #set initial density vector to be fed into IPM\n\n# set up matrix to record cover\ncovSave <- matrix(NA,tlimit,n_spp)\ncovSave[1,] <- sum_cover(inits$v,nt,inits$h,A)\n\n# set up list to store size distributions\nsizeSave <- list(NULL)\nfor(i in 1:n_spp){\n  sizeSave[[i]] <- matrix(NA,length(inits$v[[i]]),(tlimit))\n  sizeSave[[i]][,1] <- nt[[i]]/sum(nt[[i]])\n}\n\n# initial densities \nNsave <- matrix(NA,tlimit,n_spp)\nNsave[1,] <- sum_N(nt,inits$h)\n\nyrSave <- rep(NA,tlimit)\n\n# Loop through simulation times and iterate population\nfor (t in 2:(tlimit)){\n  #draw from observed year effects\n  allYrs <- c(1:Nyrs)\n  doYear <- sample(allYrs,1)\n  yrSave[t] <- doYear\n  \n  #get recruits per area\n  cover <- covSave[t-1,]\n  N <- Nsave[t-1,]\n  recs_per_area <- get_rpa(Rpars,cover,doYear)\n  \n  #calculate size-specific crowding\n  alphaG <- Gpars$alpha \n  alphaS <- Spars$alpha \n  \n  if(NoOverlap_Inter==F){#T: heterospecific genets cannot overlap; F: overlap allowed\n    for(ii in 1:n_spp){ \n      # first do all overlap W's\n      Xbar=cover*A/N       # multiply by A to get cover back in cm^2\n      varX=varN(inits$v,nt,inits$h,Xbar,N) \n      \n      muWG = pi*Xbar*N/(A*alphaG[ii,])\n      muWS = pi*Xbar*N/(A*alphaS[ii,])\n      \n      muWG[is.na(muWG)]=0\n      muWS[is.na(muWS)]=0\n      \n      inits$WmatG[[ii]]=matrix(muWG,nrow=length(inits$v[[ii]]),ncol=n_spp,byrow=T)\n      inits$WmatS[[ii]]=matrix(muWS,nrow=length(inits$v[[ii]]),ncol=n_spp,byrow=T)\n      \n      # now do conspecific no overlap W\n      inits$Ctot[ii]=inits$h[ii]*sum(inits$expv[[ii]]*nt[[ii]]) \n      inits$Cr[[ii]]=splinefun(inits$b.r[[ii]],inits$h[ii]*c(0,cumsum(inits$expv[[ii]]*nt[[ii]])),method=\"natural\")\n      \n      inits$WmatG[[ii]][,ii]=WrijG(inits$v.r[[ii]],ii,ii,inits$r.U,inits$Cr,inits$Ctot)/A\n      inits$WmatS[[ii]][,ii]=WrijS(inits$v.r[[ii]],ii,ii,inits$r.U,inits$Cr,inits$Ctot)/A\n    }\n  }else{\n    for(ii in 1:n_spp){\n      inits$Ctot[ii]=inits$h[ii]*sum(inits$expv[[ii]]*nt[[ii]]) \n      inits$Cr[[ii]]=splinefun(inits$b.r[[ii]],inits$h[ii]*c(0,cumsum(inits$expv[[ii]]*nt[[ii]])),method=\"natural\") \n    }\n    for(jj in 1:n_spp){ \n      \n      WfunG=splinefun(inits$size.range,WrijG(inits$size.range,jj,jj,inits$r.U,inits$Cr,inits$Ctot))\n      WfunS=splinefun(inits$size.range,WrijS(inits$size.range,jj,jj,inits$r.U,inits$Cr,inits$Ctot))\n      \n      for(ii in 1:n_spp) { \n        inits$WmatG[[ii]][,jj]=WfunG(inits$v.r[[ii]])/A \n        inits$WmatS[[ii]][,jj]=WfunS(inits$v.r[[ii]])/A \n      }\n    }\n    \n  } # end NoOverlap if\n  \n  for(doSpp in 1:n_spp){  \n    if(cover[doSpp]>0){    \n      # make kernels and project\n      K_matrix=make_K_matrix(inits$v[[doSpp]],inits$WmatG[[doSpp]],inits$WmatS[[doSpp]],\n                             Rpars,recs_per_area,Gpars,Spars,doYear,doSpp,inits$h)\t\n      new.nt[[doSpp]]=K_matrix%*%nt[[doSpp]] \n      sizeSave[[doSpp]][,t]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])  \n    }    \n  } # next species\n  \n  nt=new.nt \n  covSave[t,]=sum_cover(inits$v,nt,inits$h,A)  # store the cover as cm^2/cm^2\n  Nsave[t,]=sum_N(nt,inits$h)\n  \n  print(t)\n  flush.console()\n  if(sum(is.na(nt))>0) browser()  \n} # next time step\n\n\n####\n#### Some example plots to visually check results ----------------------------\n####\ncover <- as.data.frame(100*covSave[(burn_in+1):tlimit,])\ncolnames(cover) <- spp_list\ncover$year <- seq((burn_in+1),tlimit)\ncover_df <- melt(cover, id.vars = \"year\")\ncolnames(cover_df) <- c(\"Sim_Year\", \"Species\", \"Cover\")\n\ng_cover_box <- ggplot(cover_df)+\n  geom_boxplot(aes(x=Species, y=Cover, fill=Species))+\n  guides(fill=FALSE)\ng_cover_ts <- ggplot(cover_df)+\n  geom_line(aes(x=Sim_Year, y=Cover, color=Species, group=Species))\ngrid.arrange(g_cover_box, g_cover_ts, nrow=1, ncol=2)\n\n",
    "created" : 1422561647498.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1116114506",
    "id" : "4D3238A4",
    "lastKnownWriteTime" : 1422566857,
    "path" : "~/Repos/IPMdoit/inst/examples/run_idaho_example.R",
    "project_path" : "inst/examples/run_idaho_example.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}